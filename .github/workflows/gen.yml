name: "Generate"
on:
  push:
    branches: [2.*, 3.*, 4.*, main]
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  should-run:
    # This job checks if files have been changed according
    # to the filter, and sets a should-run output if
    # the filter is satisfied.
    name: Check changed files
    runs-on: ubuntu-latest
    outputs:
      should-run: ${{ steps.set-flag.outputs.SHOULD_RUN }}
    steps:
      - name: Check changed files
        id: should-run
        uses: dorny/paths-filter@v3
        with:
          filters: |
            should_run:
              - '**.go'
              - 'go.mod'
              - '.github/workflows/gen.yml'

      - name: Set flag
        id: set-flag
        run: |
          echo "SHOULD_RUN=steps.should-run.outputs.should_run" >> $GITHUB_OUTPUT

  Generate:
    needs: [should-run]
    name: Generate
    runs-on: [self-hosted, linux, arm64, aws, xxlarge]
    if: github.event.pull_request.draft == false && needs.should-run.outputs.should-run == true

    steps:
        # Since this check is marked as "required", the action needs to run on
        # every PR. However, if there were no changes to Go files, there will
        # be no changes to the generated files, hence we don't need to check.
        # So this step checks which files have been changed, and allows the
        # rest of the workflow to be skipped if no Go files were changed.
      - name: Check changed files
        id: should-run
        uses: dorny/paths-filter@v3
        with:
          filters: |
            go:
              - '**.go'
              - 'go.mod'
              - '.github/workflows/gen.yml'

      - name: "Checkout"
        uses: actions/checkout@v4

      - name: "Set up Go"
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache: true

      - name: "Delete all mocks"
         shell: bash
        # Ideally we'd delete all generated files, but we can't because some of
        # the Go code depends on generated files for go:generate to actually work.
        run: |
          for FILE in $(grep '// Code generated by MockGen. DO NOT EDIT.' -r . -l --include \*.go); do
            rm $FILE
          done

      - name: "Regenerate code"
        shell: bash
        run: |
          # Running go generate by itself is slow over a large codebase, where
          # all generate directives are dispersed over many files. Instead, the
          # following uses tools for locating and extracting the directives,
          # before piping them to go generate in parallel.
          #
          #  1. grep for go generate directive in the go files recursively.
          #  2. Grab the file name of each select file.
          #  3. Unique every file, so we only go generate the file once.
          #  4. Using xargs perform go generate in parallel.
          #
          grep -ir "//go:generate" --include '*.go' . | awk -F : '{ print $1 }' | uniq | xargs -n 1 -P 8 -I% go generate -x $(realpath %)

      - name: "Check diff"
        shell: bash
        run: |
          git add -A
          if [[ -n $(git diff HEAD) ]]; then
            # Print the full diff for debugging purposes
            git diff HEAD
            echo "*****"
            echo "The following generated files have been modified:"
            git diff --name-status HEAD
            echo "Please regenerate these files and check in the changes."
            echo "*****"
            exit 1
          fi
