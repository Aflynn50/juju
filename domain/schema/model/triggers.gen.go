// Code generated by triggergen. DO NOT EDIT.

package model

import (
	"fmt"

	"github.com/juju/juju/core/database/schema"
)


func ChangeLogTriggersForBlockDevice(columnName string, namespaceID int) func() schema.Patch {
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- BlockDevice for insert trigger
CREATE TRIGGER trg_log_block_device_insert
AFTER INSERT ON block_device FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (1, %[2]d, NEW.%[1]s, DATETIME('now'));
END;

-- BlockDevice for update trigger
CREATE TRIGGER trg_log_block_device_update
AFTER UPDATE ON block_device FOR EACH ROW
WHEN 
	NEW.machine_uuid != OLD.machine_uuid OR
	NEW.name != OLD.name OR
	(NEW.label != OLD.label OR (NEW.label IS NOT NULL AND OLD.label IS NULL) OR (NEW.label IS NULL AND OLD.label IS NOT NULL)) OR
	(NEW.device_uuid != OLD.device_uuid OR (NEW.device_uuid IS NOT NULL AND OLD.device_uuid IS NULL) OR (NEW.device_uuid IS NULL AND OLD.device_uuid IS NOT NULL)) OR
	(NEW.hardware_id != OLD.hardware_id OR (NEW.hardware_id IS NOT NULL AND OLD.hardware_id IS NULL) OR (NEW.hardware_id IS NULL AND OLD.hardware_id IS NOT NULL)) OR
	(NEW.wwn != OLD.wwn OR (NEW.wwn IS NOT NULL AND OLD.wwn IS NULL) OR (NEW.wwn IS NULL AND OLD.wwn IS NOT NULL)) OR
	(NEW.bus_address != OLD.bus_address OR (NEW.bus_address IS NOT NULL AND OLD.bus_address IS NULL) OR (NEW.bus_address IS NULL AND OLD.bus_address IS NOT NULL)) OR
	(NEW.serial_id != OLD.serial_id OR (NEW.serial_id IS NOT NULL AND OLD.serial_id IS NULL) OR (NEW.serial_id IS NULL AND OLD.serial_id IS NOT NULL)) OR
	(NEW.filesystem_type_id != OLD.filesystem_type_id OR (NEW.filesystem_type_id IS NOT NULL AND OLD.filesystem_type_id IS NULL) OR (NEW.filesystem_type_id IS NULL AND OLD.filesystem_type_id IS NOT NULL)) OR
	(NEW.size_mib != OLD.size_mib OR (NEW.size_mib IS NOT NULL AND OLD.size_mib IS NULL) OR (NEW.size_mib IS NULL AND OLD.size_mib IS NOT NULL)) OR
	(NEW.mount_point != OLD.mount_point OR (NEW.mount_point IS NOT NULL AND OLD.mount_point IS NULL) OR (NEW.mount_point IS NULL AND OLD.mount_point IS NOT NULL)) OR
	(NEW.in_use != OLD.in_use OR (NEW.in_use IS NOT NULL AND OLD.in_use IS NULL) OR (NEW.in_use IS NULL AND OLD.in_use IS NOT NULL)) 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (2, %[2]d, OLD.%[1]s, DATETIME('now'));
END;

-- BlockDevice for delete trigger
CREATE TRIGGER trg_log_block_device_delete
AFTER DELETE ON block_device FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (4, %[2]d, OLD.%[1]s, DATETIME('now'));
END;`, columnName, namespaceID))
	}
}

func ChangeLogTriggersForModelConfig(columnName string, namespaceID int) func() schema.Patch {
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- ModelConfig for insert trigger
CREATE TRIGGER trg_log_model_config_insert
AFTER INSERT ON model_config FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (1, %[2]d, NEW.%[1]s, DATETIME('now'));
END;

-- ModelConfig for update trigger
CREATE TRIGGER trg_log_model_config_update
AFTER UPDATE ON model_config FOR EACH ROW
WHEN 
	NEW.value != OLD.value 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (2, %[2]d, OLD.%[1]s, DATETIME('now'));
END;

-- ModelConfig for delete trigger
CREATE TRIGGER trg_log_model_config_delete
AFTER DELETE ON model_config FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (4, %[2]d, OLD.%[1]s, DATETIME('now'));
END;`, columnName, namespaceID))
	}
}

func ChangeLogTriggersForObjectStoreMetadataPath(columnName string, namespaceID int) func() schema.Patch {
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- ObjectStoreMetadataPath for insert trigger
CREATE TRIGGER trg_log_object_store_metadata_path_insert
AFTER INSERT ON object_store_metadata_path FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (1, %[2]d, NEW.%[1]s, DATETIME('now'));
END;

-- ObjectStoreMetadataPath for update trigger
CREATE TRIGGER trg_log_object_store_metadata_path_update
AFTER UPDATE ON object_store_metadata_path FOR EACH ROW
WHEN 
	NEW.metadata_uuid != OLD.metadata_uuid 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (2, %[2]d, OLD.%[1]s, DATETIME('now'));
END;

-- ObjectStoreMetadataPath for delete trigger
CREATE TRIGGER trg_log_object_store_metadata_path_delete
AFTER DELETE ON object_store_metadata_path FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (4, %[2]d, OLD.%[1]s, DATETIME('now'));
END;`, columnName, namespaceID))
	}
}

func ChangeLogTriggersForSecretMetadata(columnName string, namespaceID int) func() schema.Patch {
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- SecretMetadata for insert trigger
CREATE TRIGGER trg_log_secret_metadata_insert
AFTER INSERT ON secret_metadata FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (1, %[2]d, NEW.%[1]s, DATETIME('now'));
END;

-- SecretMetadata for update trigger
CREATE TRIGGER trg_log_secret_metadata_update
AFTER UPDATE ON secret_metadata FOR EACH ROW
WHEN 
	NEW.version != OLD.version OR
	(NEW.description != OLD.description OR (NEW.description IS NOT NULL AND OLD.description IS NULL) OR (NEW.description IS NULL AND OLD.description IS NOT NULL)) OR
	NEW.rotate_policy_id != OLD.rotate_policy_id OR
	NEW.auto_prune != OLD.auto_prune OR
	NEW.create_time != OLD.create_time OR
	NEW.update_time != OLD.update_time 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (2, %[2]d, OLD.%[1]s, DATETIME('now'));
END;

-- SecretMetadata for delete trigger
CREATE TRIGGER trg_log_secret_metadata_delete
AFTER DELETE ON secret_metadata FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (4, %[2]d, OLD.%[1]s, DATETIME('now'));
END;`, columnName, namespaceID))
	}
}

func ChangeLogTriggersForSecretReference(columnName string, namespaceID int) func() schema.Patch {
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- SecretReference for insert trigger
CREATE TRIGGER trg_log_secret_reference_insert
AFTER INSERT ON secret_reference FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (1, %[2]d, NEW.%[1]s, DATETIME('now'));
END;

-- SecretReference for update trigger
CREATE TRIGGER trg_log_secret_reference_update
AFTER UPDATE ON secret_reference FOR EACH ROW
WHEN 
	NEW.latest_revision != OLD.latest_revision 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (2, %[2]d, OLD.%[1]s, DATETIME('now'));
END;

-- SecretReference for delete trigger
CREATE TRIGGER trg_log_secret_reference_delete
AFTER DELETE ON secret_reference FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (4, %[2]d, OLD.%[1]s, DATETIME('now'));
END;`, columnName, namespaceID))
	}
}

func ChangeLogTriggersForSecretRevision(columnName string, namespaceID int) func() schema.Patch {
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- SecretRevision for insert trigger
CREATE TRIGGER trg_log_secret_revision_insert
AFTER INSERT ON secret_revision FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (1, %[2]d, NEW.%[1]s, DATETIME('now'));
END;

-- SecretRevision for update trigger
CREATE TRIGGER trg_log_secret_revision_update
AFTER UPDATE ON secret_revision FOR EACH ROW
WHEN 
	NEW.secret_id != OLD.secret_id OR
	NEW.revision != OLD.revision OR
	NEW.create_time != OLD.create_time 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (2, %[2]d, OLD.%[1]s, DATETIME('now'));
END;

-- SecretRevision for delete trigger
CREATE TRIGGER trg_log_secret_revision_delete
AFTER DELETE ON secret_revision FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (4, %[2]d, OLD.%[1]s, DATETIME('now'));
END;`, columnName, namespaceID))
	}
}

func ChangeLogTriggersForSecretRevisionExpire(columnName string, namespaceID int) func() schema.Patch {
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- SecretRevisionExpire for insert trigger
CREATE TRIGGER trg_log_secret_revision_expire_insert
AFTER INSERT ON secret_revision_expire FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (1, %[2]d, NEW.%[1]s, DATETIME('now'));
END;

-- SecretRevisionExpire for update trigger
CREATE TRIGGER trg_log_secret_revision_expire_update
AFTER UPDATE ON secret_revision_expire FOR EACH ROW
WHEN 
	NEW.expire_time != OLD.expire_time 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (2, %[2]d, OLD.%[1]s, DATETIME('now'));
END;

-- SecretRevisionExpire for delete trigger
CREATE TRIGGER trg_log_secret_revision_expire_delete
AFTER DELETE ON secret_revision_expire FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (4, %[2]d, OLD.%[1]s, DATETIME('now'));
END;`, columnName, namespaceID))
	}
}

func ChangeLogTriggersForSecretRevisionObsolete(columnName string, namespaceID int) func() schema.Patch {
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- SecretRevisionObsolete for insert trigger
CREATE TRIGGER trg_log_secret_revision_obsolete_insert
AFTER INSERT ON secret_revision_obsolete FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (1, %[2]d, NEW.%[1]s, DATETIME('now'));
END;

-- SecretRevisionObsolete for update trigger
CREATE TRIGGER trg_log_secret_revision_obsolete_update
AFTER UPDATE ON secret_revision_obsolete FOR EACH ROW
WHEN 
	NEW.obsolete != OLD.obsolete OR
	NEW.pending_delete != OLD.pending_delete 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (2, %[2]d, OLD.%[1]s, DATETIME('now'));
END;

-- SecretRevisionObsolete for delete trigger
CREATE TRIGGER trg_log_secret_revision_obsolete_delete
AFTER DELETE ON secret_revision_obsolete FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (4, %[2]d, OLD.%[1]s, DATETIME('now'));
END;`, columnName, namespaceID))
	}
}

func ChangeLogTriggersForSecretRotation(columnName string, namespaceID int) func() schema.Patch {
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- SecretRotation for insert trigger
CREATE TRIGGER trg_log_secret_rotation_insert
AFTER INSERT ON secret_rotation FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (1, %[2]d, NEW.%[1]s, DATETIME('now'));
END;

-- SecretRotation for update trigger
CREATE TRIGGER trg_log_secret_rotation_update
AFTER UPDATE ON secret_rotation FOR EACH ROW
WHEN 
	NEW.next_rotation_time != OLD.next_rotation_time 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (2, %[2]d, OLD.%[1]s, DATETIME('now'));
END;

-- SecretRotation for delete trigger
CREATE TRIGGER trg_log_secret_rotation_delete
AFTER DELETE ON secret_rotation FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (4, %[2]d, OLD.%[1]s, DATETIME('now'));
END;`, columnName, namespaceID))
	}
}

func ChangeLogTriggersForStorageAttachment(columnName string, namespaceID int) func() schema.Patch {
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- StorageAttachment for insert trigger
CREATE TRIGGER trg_log_storage_attachment_insert
AFTER INSERT ON storage_attachment FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (1, %[2]d, NEW.%[1]s, DATETIME('now'));
END;

-- StorageAttachment for update trigger
CREATE TRIGGER trg_log_storage_attachment_update
AFTER UPDATE ON storage_attachment FOR EACH ROW
WHEN 
	NEW.unit_uuid != OLD.unit_uuid OR
	NEW.life_id != OLD.life_id 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (2, %[2]d, OLD.%[1]s, DATETIME('now'));
END;

-- StorageAttachment for delete trigger
CREATE TRIGGER trg_log_storage_attachment_delete
AFTER DELETE ON storage_attachment FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (4, %[2]d, OLD.%[1]s, DATETIME('now'));
END;`, columnName, namespaceID))
	}
}

func ChangeLogTriggersForStorageFilesystem(columnName string, namespaceID int) func() schema.Patch {
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- StorageFilesystem for insert trigger
CREATE TRIGGER trg_log_storage_filesystem_insert
AFTER INSERT ON storage_filesystem FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (1, %[2]d, NEW.%[1]s, DATETIME('now'));
END;

-- StorageFilesystem for update trigger
CREATE TRIGGER trg_log_storage_filesystem_update
AFTER UPDATE ON storage_filesystem FOR EACH ROW
WHEN 
	NEW.life_id != OLD.life_id OR
	(NEW.provider_id != OLD.provider_id OR (NEW.provider_id IS NOT NULL AND OLD.provider_id IS NULL) OR (NEW.provider_id IS NULL AND OLD.provider_id IS NOT NULL)) OR
	(NEW.storage_pool_uuid != OLD.storage_pool_uuid OR (NEW.storage_pool_uuid IS NOT NULL AND OLD.storage_pool_uuid IS NULL) OR (NEW.storage_pool_uuid IS NULL AND OLD.storage_pool_uuid IS NOT NULL)) OR
	(NEW.size_mib != OLD.size_mib OR (NEW.size_mib IS NOT NULL AND OLD.size_mib IS NULL) OR (NEW.size_mib IS NULL AND OLD.size_mib IS NOT NULL)) OR
	NEW.provisioning_status_id != OLD.provisioning_status_id 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (2, %[2]d, OLD.%[1]s, DATETIME('now'));
END;

-- StorageFilesystem for delete trigger
CREATE TRIGGER trg_log_storage_filesystem_delete
AFTER DELETE ON storage_filesystem FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (4, %[2]d, OLD.%[1]s, DATETIME('now'));
END;`, columnName, namespaceID))
	}
}

func ChangeLogTriggersForStorageFilesystemAttachment(columnName string, namespaceID int) func() schema.Patch {
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- StorageFilesystemAttachment for insert trigger
CREATE TRIGGER trg_log_storage_filesystem_attachment_insert
AFTER INSERT ON storage_filesystem_attachment FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (1, %[2]d, NEW.%[1]s, DATETIME('now'));
END;

-- StorageFilesystemAttachment for update trigger
CREATE TRIGGER trg_log_storage_filesystem_attachment_update
AFTER UPDATE ON storage_filesystem_attachment FOR EACH ROW
WHEN 
	NEW.storage_filesystem_uuid != OLD.storage_filesystem_uuid OR
	NEW.net_node_uuid != OLD.net_node_uuid OR
	NEW.life_id != OLD.life_id OR
	(NEW.mount_point != OLD.mount_point OR (NEW.mount_point IS NOT NULL AND OLD.mount_point IS NULL) OR (NEW.mount_point IS NULL AND OLD.mount_point IS NOT NULL)) OR
	(NEW.read_only != OLD.read_only OR (NEW.read_only IS NOT NULL AND OLD.read_only IS NULL) OR (NEW.read_only IS NULL AND OLD.read_only IS NOT NULL)) OR
	NEW.provisioning_status_id != OLD.provisioning_status_id 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (2, %[2]d, OLD.%[1]s, DATETIME('now'));
END;

-- StorageFilesystemAttachment for delete trigger
CREATE TRIGGER trg_log_storage_filesystem_attachment_delete
AFTER DELETE ON storage_filesystem_attachment FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (4, %[2]d, OLD.%[1]s, DATETIME('now'));
END;`, columnName, namespaceID))
	}
}

func ChangeLogTriggersForStorageVolume(columnName string, namespaceID int) func() schema.Patch {
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- StorageVolume for insert trigger
CREATE TRIGGER trg_log_storage_volume_insert
AFTER INSERT ON storage_volume FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (1, %[2]d, NEW.%[1]s, DATETIME('now'));
END;

-- StorageVolume for update trigger
CREATE TRIGGER trg_log_storage_volume_update
AFTER UPDATE ON storage_volume FOR EACH ROW
WHEN 
	NEW.life_id != OLD.life_id OR
	NEW.name != OLD.name OR
	(NEW.provider_id != OLD.provider_id OR (NEW.provider_id IS NOT NULL AND OLD.provider_id IS NULL) OR (NEW.provider_id IS NULL AND OLD.provider_id IS NOT NULL)) OR
	(NEW.storage_pool_uuid != OLD.storage_pool_uuid OR (NEW.storage_pool_uuid IS NOT NULL AND OLD.storage_pool_uuid IS NULL) OR (NEW.storage_pool_uuid IS NULL AND OLD.storage_pool_uuid IS NOT NULL)) OR
	(NEW.size_mib != OLD.size_mib OR (NEW.size_mib IS NOT NULL AND OLD.size_mib IS NULL) OR (NEW.size_mib IS NULL AND OLD.size_mib IS NOT NULL)) OR
	(NEW.hardware_id != OLD.hardware_id OR (NEW.hardware_id IS NOT NULL AND OLD.hardware_id IS NULL) OR (NEW.hardware_id IS NULL AND OLD.hardware_id IS NOT NULL)) OR
	(NEW.wwn != OLD.wwn OR (NEW.wwn IS NOT NULL AND OLD.wwn IS NULL) OR (NEW.wwn IS NULL AND OLD.wwn IS NOT NULL)) OR
	(NEW.persistent != OLD.persistent OR (NEW.persistent IS NOT NULL AND OLD.persistent IS NULL) OR (NEW.persistent IS NULL AND OLD.persistent IS NOT NULL)) OR
	NEW.provisioning_status_id != OLD.provisioning_status_id 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (2, %[2]d, OLD.%[1]s, DATETIME('now'));
END;

-- StorageVolume for delete trigger
CREATE TRIGGER trg_log_storage_volume_delete
AFTER DELETE ON storage_volume FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (4, %[2]d, OLD.%[1]s, DATETIME('now'));
END;`, columnName, namespaceID))
	}
}

func ChangeLogTriggersForStorageVolumeAttachment(columnName string, namespaceID int) func() schema.Patch {
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- StorageVolumeAttachment for insert trigger
CREATE TRIGGER trg_log_storage_volume_attachment_insert
AFTER INSERT ON storage_volume_attachment FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (1, %[2]d, NEW.%[1]s, DATETIME('now'));
END;

-- StorageVolumeAttachment for update trigger
CREATE TRIGGER trg_log_storage_volume_attachment_update
AFTER UPDATE ON storage_volume_attachment FOR EACH ROW
WHEN 
	NEW.storage_volume_uuid != OLD.storage_volume_uuid OR
	NEW.net_node_uuid != OLD.net_node_uuid OR
	NEW.life_id != OLD.life_id OR
	(NEW.block_device_uuid != OLD.block_device_uuid OR (NEW.block_device_uuid IS NOT NULL AND OLD.block_device_uuid IS NULL) OR (NEW.block_device_uuid IS NULL AND OLD.block_device_uuid IS NOT NULL)) OR
	(NEW.read_only != OLD.read_only OR (NEW.read_only IS NOT NULL AND OLD.read_only IS NULL) OR (NEW.read_only IS NULL AND OLD.read_only IS NOT NULL)) OR
	NEW.provisioning_status_id != OLD.provisioning_status_id 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (2, %[2]d, OLD.%[1]s, DATETIME('now'));
END;

-- StorageVolumeAttachment for delete trigger
CREATE TRIGGER trg_log_storage_volume_attachment_delete
AFTER DELETE ON storage_volume_attachment FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (4, %[2]d, OLD.%[1]s, DATETIME('now'));
END;`, columnName, namespaceID))
	}
}

func ChangeLogTriggersForStorageVolumeAttachmentPlan(columnName string, namespaceID int) func() schema.Patch {
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- StorageVolumeAttachmentPlan for insert trigger
CREATE TRIGGER trg_log_storage_volume_attachment_plan_insert
AFTER INSERT ON storage_volume_attachment_plan FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (1, %[2]d, NEW.%[1]s, DATETIME('now'));
END;

-- StorageVolumeAttachmentPlan for update trigger
CREATE TRIGGER trg_log_storage_volume_attachment_plan_update
AFTER UPDATE ON storage_volume_attachment_plan FOR EACH ROW
WHEN 
	NEW.storage_volume_uuid != OLD.storage_volume_uuid OR
	NEW.net_node_uuid != OLD.net_node_uuid OR
	NEW.life_id != OLD.life_id OR
	(NEW.device_type_id != OLD.device_type_id OR (NEW.device_type_id IS NOT NULL AND OLD.device_type_id IS NULL) OR (NEW.device_type_id IS NULL AND OLD.device_type_id IS NOT NULL)) OR
	(NEW.block_device_uuid != OLD.block_device_uuid OR (NEW.block_device_uuid IS NOT NULL AND OLD.block_device_uuid IS NULL) OR (NEW.block_device_uuid IS NULL AND OLD.block_device_uuid IS NOT NULL)) OR
	NEW.provisioning_status_id != OLD.provisioning_status_id 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (2, %[2]d, OLD.%[1]s, DATETIME('now'));
END;

-- StorageVolumeAttachmentPlan for delete trigger
CREATE TRIGGER trg_log_storage_volume_attachment_plan_delete
AFTER DELETE ON storage_volume_attachment_plan FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (4, %[2]d, OLD.%[1]s, DATETIME('now'));
END;`, columnName, namespaceID))
	}
}

func ChangeLogTriggersForSubnet(columnName string, namespaceID int) func() schema.Patch {
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- Subnet for insert trigger
CREATE TRIGGER trg_log_subnet_insert
AFTER INSERT ON subnet FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (1, %[2]d, NEW.%[1]s, DATETIME('now'));
END;

-- Subnet for update trigger
CREATE TRIGGER trg_log_subnet_update
AFTER UPDATE ON subnet FOR EACH ROW
WHEN 
	NEW.cidr != OLD.cidr OR
	(NEW.vlan_tag != OLD.vlan_tag OR (NEW.vlan_tag IS NOT NULL AND OLD.vlan_tag IS NULL) OR (NEW.vlan_tag IS NULL AND OLD.vlan_tag IS NOT NULL)) OR
	(NEW.space_uuid != OLD.space_uuid OR (NEW.space_uuid IS NOT NULL AND OLD.space_uuid IS NULL) OR (NEW.space_uuid IS NULL AND OLD.space_uuid IS NOT NULL)) OR
	(NEW.subnet_type_id != OLD.subnet_type_id OR (NEW.subnet_type_id IS NOT NULL AND OLD.subnet_type_id IS NULL) OR (NEW.subnet_type_id IS NULL AND OLD.subnet_type_id IS NOT NULL)) 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (2, %[2]d, OLD.%[1]s, DATETIME('now'));
END;

-- Subnet for delete trigger
CREATE TRIGGER trg_log_subnet_delete
AFTER DELETE ON subnet FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (4, %[2]d, OLD.%[1]s, DATETIME('now'));
END;`, columnName, namespaceID))
	}
}

func ChangeLogTriggersForSubnetAssociation(columnName string, namespaceID int) func() schema.Patch {
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- SubnetAssociation for insert trigger
CREATE TRIGGER trg_log_subnet_association_insert
AFTER INSERT ON subnet_association FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (1, %[2]d, NEW.%[1]s, DATETIME('now'));
END;

-- SubnetAssociation for update trigger
CREATE TRIGGER trg_log_subnet_association_update
AFTER UPDATE ON subnet_association FOR EACH ROW
WHEN 
	NEW.associated_subnet_uuid != OLD.associated_subnet_uuid OR
	NEW.association_type_id != OLD.association_type_id 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (2, %[2]d, OLD.%[1]s, DATETIME('now'));
END;

-- SubnetAssociation for delete trigger
CREATE TRIGGER trg_log_subnet_association_delete
AFTER DELETE ON subnet_association FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, changed, created_at)
    VALUES (4, %[2]d, OLD.%[1]s, DATETIME('now'));
END;`, columnName, namespaceID))
	}
}

