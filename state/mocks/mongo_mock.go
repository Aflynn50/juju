// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/juju/juju/internal/mongo (interfaces: Collection,Query)
//
// Generated by this command:
//
//	mockgen -typed -package mocks -destination mocks/mongo_mock.go github.com/juju/juju/internal/mongo Collection,Query
//

// Package mocks is a generated GoMock package.
package mocks

import (
	reflect "reflect"
	time "time"

	mongo "github.com/juju/juju/internal/mongo"
	mgo "github.com/juju/mgo/v3"
	gomock "go.uber.org/mock/gomock"
)

// MockCollection is a mock of Collection interface.
type MockCollection struct {
	ctrl     *gomock.Controller
	recorder *MockCollectionMockRecorder
}

// MockCollectionMockRecorder is the mock recorder for MockCollection.
type MockCollectionMockRecorder struct {
	mock *MockCollection
}

// NewMockCollection creates a new mock instance.
func NewMockCollection(ctrl *gomock.Controller) *MockCollection {
	mock := &MockCollection{ctrl: ctrl}
	mock.recorder = &MockCollectionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCollection) EXPECT() *MockCollectionMockRecorder {
	return m.recorder
}

// Count mocks base method.
func (m *MockCollection) Count() (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Count")
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Count indicates an expected call of Count.
func (mr *MockCollectionMockRecorder) Count() *MockCollectionCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockCollection)(nil).Count))
	return &MockCollectionCountCall{Call: call}
}

// MockCollectionCountCall wrap *gomock.Call
type MockCollectionCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCollectionCountCall) Return(arg0 int, arg1 error) *MockCollectionCountCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCollectionCountCall) Do(f func() (int, error)) *MockCollectionCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCollectionCountCall) DoAndReturn(f func() (int, error)) *MockCollectionCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Find mocks base method.
func (m *MockCollection) Find(arg0 any) mongo.Query {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Find", arg0)
	ret0, _ := ret[0].(mongo.Query)
	return ret0
}

// Find indicates an expected call of Find.
func (mr *MockCollectionMockRecorder) Find(arg0 any) *MockCollectionFindCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Find", reflect.TypeOf((*MockCollection)(nil).Find), arg0)
	return &MockCollectionFindCall{Call: call}
}

// MockCollectionFindCall wrap *gomock.Call
type MockCollectionFindCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCollectionFindCall) Return(arg0 mongo.Query) *MockCollectionFindCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCollectionFindCall) Do(f func(any) mongo.Query) *MockCollectionFindCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCollectionFindCall) DoAndReturn(f func(any) mongo.Query) *MockCollectionFindCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindId mocks base method.
func (m *MockCollection) FindId(arg0 any) mongo.Query {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindId", arg0)
	ret0, _ := ret[0].(mongo.Query)
	return ret0
}

// FindId indicates an expected call of FindId.
func (mr *MockCollectionMockRecorder) FindId(arg0 any) *MockCollectionFindIdCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindId", reflect.TypeOf((*MockCollection)(nil).FindId), arg0)
	return &MockCollectionFindIdCall{Call: call}
}

// MockCollectionFindIdCall wrap *gomock.Call
type MockCollectionFindIdCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCollectionFindIdCall) Return(arg0 mongo.Query) *MockCollectionFindIdCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCollectionFindIdCall) Do(f func(any) mongo.Query) *MockCollectionFindIdCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCollectionFindIdCall) DoAndReturn(f func(any) mongo.Query) *MockCollectionFindIdCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Name mocks base method.
func (m *MockCollection) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockCollectionMockRecorder) Name() *MockCollectionNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockCollection)(nil).Name))
	return &MockCollectionNameCall{Call: call}
}

// MockCollectionNameCall wrap *gomock.Call
type MockCollectionNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCollectionNameCall) Return(arg0 string) *MockCollectionNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCollectionNameCall) Do(f func() string) *MockCollectionNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCollectionNameCall) DoAndReturn(f func() string) *MockCollectionNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Pipe mocks base method.
func (m *MockCollection) Pipe(arg0 any) *mgo.Pipe {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Pipe", arg0)
	ret0, _ := ret[0].(*mgo.Pipe)
	return ret0
}

// Pipe indicates an expected call of Pipe.
func (mr *MockCollectionMockRecorder) Pipe(arg0 any) *MockCollectionPipeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pipe", reflect.TypeOf((*MockCollection)(nil).Pipe), arg0)
	return &MockCollectionPipeCall{Call: call}
}

// MockCollectionPipeCall wrap *gomock.Call
type MockCollectionPipeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCollectionPipeCall) Return(arg0 *mgo.Pipe) *MockCollectionPipeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCollectionPipeCall) Do(f func(any) *mgo.Pipe) *MockCollectionPipeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCollectionPipeCall) DoAndReturn(f func(any) *mgo.Pipe) *MockCollectionPipeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Writeable mocks base method.
func (m *MockCollection) Writeable() mongo.WriteCollection {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Writeable")
	ret0, _ := ret[0].(mongo.WriteCollection)
	return ret0
}

// Writeable indicates an expected call of Writeable.
func (mr *MockCollectionMockRecorder) Writeable() *MockCollectionWriteableCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Writeable", reflect.TypeOf((*MockCollection)(nil).Writeable))
	return &MockCollectionWriteableCall{Call: call}
}

// MockCollectionWriteableCall wrap *gomock.Call
type MockCollectionWriteableCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCollectionWriteableCall) Return(arg0 mongo.WriteCollection) *MockCollectionWriteableCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCollectionWriteableCall) Do(f func() mongo.WriteCollection) *MockCollectionWriteableCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCollectionWriteableCall) DoAndReturn(f func() mongo.WriteCollection) *MockCollectionWriteableCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockQuery is a mock of Query interface.
type MockQuery struct {
	ctrl     *gomock.Controller
	recorder *MockQueryMockRecorder
}

// MockQueryMockRecorder is the mock recorder for MockQuery.
type MockQueryMockRecorder struct {
	mock *MockQuery
}

// NewMockQuery creates a new mock instance.
func NewMockQuery(ctrl *gomock.Controller) *MockQuery {
	mock := &MockQuery{ctrl: ctrl}
	mock.recorder = &MockQueryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQuery) EXPECT() *MockQueryMockRecorder {
	return m.recorder
}

// All mocks base method.
func (m *MockQuery) All(arg0 any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "All", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// All indicates an expected call of All.
func (mr *MockQueryMockRecorder) All(arg0 any) *MockQueryAllCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "All", reflect.TypeOf((*MockQuery)(nil).All), arg0)
	return &MockQueryAllCall{Call: call}
}

// MockQueryAllCall wrap *gomock.Call
type MockQueryAllCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQueryAllCall) Return(arg0 error) *MockQueryAllCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQueryAllCall) Do(f func(any) error) *MockQueryAllCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQueryAllCall) DoAndReturn(f func(any) error) *MockQueryAllCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Apply mocks base method.
func (m *MockQuery) Apply(arg0 mgo.Change, arg1 any) (*mgo.ChangeInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Apply", arg0, arg1)
	ret0, _ := ret[0].(*mgo.ChangeInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Apply indicates an expected call of Apply.
func (mr *MockQueryMockRecorder) Apply(arg0, arg1 any) *MockQueryApplyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Apply", reflect.TypeOf((*MockQuery)(nil).Apply), arg0, arg1)
	return &MockQueryApplyCall{Call: call}
}

// MockQueryApplyCall wrap *gomock.Call
type MockQueryApplyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQueryApplyCall) Return(arg0 *mgo.ChangeInfo, arg1 error) *MockQueryApplyCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQueryApplyCall) Do(f func(mgo.Change, any) (*mgo.ChangeInfo, error)) *MockQueryApplyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQueryApplyCall) DoAndReturn(f func(mgo.Change, any) (*mgo.ChangeInfo, error)) *MockQueryApplyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Batch mocks base method.
func (m *MockQuery) Batch(arg0 int) mongo.Query {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Batch", arg0)
	ret0, _ := ret[0].(mongo.Query)
	return ret0
}

// Batch indicates an expected call of Batch.
func (mr *MockQueryMockRecorder) Batch(arg0 any) *MockQueryBatchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Batch", reflect.TypeOf((*MockQuery)(nil).Batch), arg0)
	return &MockQueryBatchCall{Call: call}
}

// MockQueryBatchCall wrap *gomock.Call
type MockQueryBatchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQueryBatchCall) Return(arg0 mongo.Query) *MockQueryBatchCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQueryBatchCall) Do(f func(int) mongo.Query) *MockQueryBatchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQueryBatchCall) DoAndReturn(f func(int) mongo.Query) *MockQueryBatchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Comment mocks base method.
func (m *MockQuery) Comment(arg0 string) mongo.Query {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Comment", arg0)
	ret0, _ := ret[0].(mongo.Query)
	return ret0
}

// Comment indicates an expected call of Comment.
func (mr *MockQueryMockRecorder) Comment(arg0 any) *MockQueryCommentCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Comment", reflect.TypeOf((*MockQuery)(nil).Comment), arg0)
	return &MockQueryCommentCall{Call: call}
}

// MockQueryCommentCall wrap *gomock.Call
type MockQueryCommentCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQueryCommentCall) Return(arg0 mongo.Query) *MockQueryCommentCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQueryCommentCall) Do(f func(string) mongo.Query) *MockQueryCommentCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQueryCommentCall) DoAndReturn(f func(string) mongo.Query) *MockQueryCommentCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Count mocks base method.
func (m *MockQuery) Count() (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Count")
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Count indicates an expected call of Count.
func (mr *MockQueryMockRecorder) Count() *MockQueryCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockQuery)(nil).Count))
	return &MockQueryCountCall{Call: call}
}

// MockQueryCountCall wrap *gomock.Call
type MockQueryCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQueryCountCall) Return(arg0 int, arg1 error) *MockQueryCountCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQueryCountCall) Do(f func() (int, error)) *MockQueryCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQueryCountCall) DoAndReturn(f func() (int, error)) *MockQueryCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Distinct mocks base method.
func (m *MockQuery) Distinct(arg0 string, arg1 any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Distinct", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Distinct indicates an expected call of Distinct.
func (mr *MockQueryMockRecorder) Distinct(arg0, arg1 any) *MockQueryDistinctCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Distinct", reflect.TypeOf((*MockQuery)(nil).Distinct), arg0, arg1)
	return &MockQueryDistinctCall{Call: call}
}

// MockQueryDistinctCall wrap *gomock.Call
type MockQueryDistinctCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQueryDistinctCall) Return(arg0 error) *MockQueryDistinctCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQueryDistinctCall) Do(f func(string, any) error) *MockQueryDistinctCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQueryDistinctCall) DoAndReturn(f func(string, any) error) *MockQueryDistinctCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Explain mocks base method.
func (m *MockQuery) Explain(arg0 any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Explain", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Explain indicates an expected call of Explain.
func (mr *MockQueryMockRecorder) Explain(arg0 any) *MockQueryExplainCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Explain", reflect.TypeOf((*MockQuery)(nil).Explain), arg0)
	return &MockQueryExplainCall{Call: call}
}

// MockQueryExplainCall wrap *gomock.Call
type MockQueryExplainCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQueryExplainCall) Return(arg0 error) *MockQueryExplainCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQueryExplainCall) Do(f func(any) error) *MockQueryExplainCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQueryExplainCall) DoAndReturn(f func(any) error) *MockQueryExplainCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// For mocks base method.
func (m *MockQuery) For(arg0 any, arg1 func() error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "For", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// For indicates an expected call of For.
func (mr *MockQueryMockRecorder) For(arg0, arg1 any) *MockQueryForCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "For", reflect.TypeOf((*MockQuery)(nil).For), arg0, arg1)
	return &MockQueryForCall{Call: call}
}

// MockQueryForCall wrap *gomock.Call
type MockQueryForCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQueryForCall) Return(arg0 error) *MockQueryForCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQueryForCall) Do(f func(any, func() error) error) *MockQueryForCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQueryForCall) DoAndReturn(f func(any, func() error) error) *MockQueryForCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Hint mocks base method.
func (m *MockQuery) Hint(arg0 ...string) mongo.Query {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Hint", varargs...)
	ret0, _ := ret[0].(mongo.Query)
	return ret0
}

// Hint indicates an expected call of Hint.
func (mr *MockQueryMockRecorder) Hint(arg0 ...any) *MockQueryHintCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Hint", reflect.TypeOf((*MockQuery)(nil).Hint), arg0...)
	return &MockQueryHintCall{Call: call}
}

// MockQueryHintCall wrap *gomock.Call
type MockQueryHintCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQueryHintCall) Return(arg0 mongo.Query) *MockQueryHintCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQueryHintCall) Do(f func(...string) mongo.Query) *MockQueryHintCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQueryHintCall) DoAndReturn(f func(...string) mongo.Query) *MockQueryHintCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Iter mocks base method.
func (m *MockQuery) Iter() mongo.Iterator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Iter")
	ret0, _ := ret[0].(mongo.Iterator)
	return ret0
}

// Iter indicates an expected call of Iter.
func (mr *MockQueryMockRecorder) Iter() *MockQueryIterCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Iter", reflect.TypeOf((*MockQuery)(nil).Iter))
	return &MockQueryIterCall{Call: call}
}

// MockQueryIterCall wrap *gomock.Call
type MockQueryIterCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQueryIterCall) Return(arg0 mongo.Iterator) *MockQueryIterCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQueryIterCall) Do(f func() mongo.Iterator) *MockQueryIterCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQueryIterCall) DoAndReturn(f func() mongo.Iterator) *MockQueryIterCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Limit mocks base method.
func (m *MockQuery) Limit(arg0 int) mongo.Query {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Limit", arg0)
	ret0, _ := ret[0].(mongo.Query)
	return ret0
}

// Limit indicates an expected call of Limit.
func (mr *MockQueryMockRecorder) Limit(arg0 any) *MockQueryLimitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Limit", reflect.TypeOf((*MockQuery)(nil).Limit), arg0)
	return &MockQueryLimitCall{Call: call}
}

// MockQueryLimitCall wrap *gomock.Call
type MockQueryLimitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQueryLimitCall) Return(arg0 mongo.Query) *MockQueryLimitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQueryLimitCall) Do(f func(int) mongo.Query) *MockQueryLimitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQueryLimitCall) DoAndReturn(f func(int) mongo.Query) *MockQueryLimitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LogReplay mocks base method.
func (m *MockQuery) LogReplay() mongo.Query {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LogReplay")
	ret0, _ := ret[0].(mongo.Query)
	return ret0
}

// LogReplay indicates an expected call of LogReplay.
func (mr *MockQueryMockRecorder) LogReplay() *MockQueryLogReplayCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LogReplay", reflect.TypeOf((*MockQuery)(nil).LogReplay))
	return &MockQueryLogReplayCall{Call: call}
}

// MockQueryLogReplayCall wrap *gomock.Call
type MockQueryLogReplayCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQueryLogReplayCall) Return(arg0 mongo.Query) *MockQueryLogReplayCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQueryLogReplayCall) Do(f func() mongo.Query) *MockQueryLogReplayCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQueryLogReplayCall) DoAndReturn(f func() mongo.Query) *MockQueryLogReplayCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MapReduce mocks base method.
func (m *MockQuery) MapReduce(arg0 *mgo.MapReduce, arg1 any) (*mgo.MapReduceInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MapReduce", arg0, arg1)
	ret0, _ := ret[0].(*mgo.MapReduceInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MapReduce indicates an expected call of MapReduce.
func (mr *MockQueryMockRecorder) MapReduce(arg0, arg1 any) *MockQueryMapReduceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MapReduce", reflect.TypeOf((*MockQuery)(nil).MapReduce), arg0, arg1)
	return &MockQueryMapReduceCall{Call: call}
}

// MockQueryMapReduceCall wrap *gomock.Call
type MockQueryMapReduceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQueryMapReduceCall) Return(arg0 *mgo.MapReduceInfo, arg1 error) *MockQueryMapReduceCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQueryMapReduceCall) Do(f func(*mgo.MapReduce, any) (*mgo.MapReduceInfo, error)) *MockQueryMapReduceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQueryMapReduceCall) DoAndReturn(f func(*mgo.MapReduce, any) (*mgo.MapReduceInfo, error)) *MockQueryMapReduceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// One mocks base method.
func (m *MockQuery) One(arg0 any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "One", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// One indicates an expected call of One.
func (mr *MockQueryMockRecorder) One(arg0 any) *MockQueryOneCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "One", reflect.TypeOf((*MockQuery)(nil).One), arg0)
	return &MockQueryOneCall{Call: call}
}

// MockQueryOneCall wrap *gomock.Call
type MockQueryOneCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQueryOneCall) Return(arg0 error) *MockQueryOneCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQueryOneCall) Do(f func(any) error) *MockQueryOneCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQueryOneCall) DoAndReturn(f func(any) error) *MockQueryOneCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Prefetch mocks base method.
func (m *MockQuery) Prefetch(arg0 float64) mongo.Query {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Prefetch", arg0)
	ret0, _ := ret[0].(mongo.Query)
	return ret0
}

// Prefetch indicates an expected call of Prefetch.
func (mr *MockQueryMockRecorder) Prefetch(arg0 any) *MockQueryPrefetchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Prefetch", reflect.TypeOf((*MockQuery)(nil).Prefetch), arg0)
	return &MockQueryPrefetchCall{Call: call}
}

// MockQueryPrefetchCall wrap *gomock.Call
type MockQueryPrefetchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQueryPrefetchCall) Return(arg0 mongo.Query) *MockQueryPrefetchCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQueryPrefetchCall) Do(f func(float64) mongo.Query) *MockQueryPrefetchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQueryPrefetchCall) DoAndReturn(f func(float64) mongo.Query) *MockQueryPrefetchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Select mocks base method.
func (m *MockQuery) Select(arg0 any) mongo.Query {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Select", arg0)
	ret0, _ := ret[0].(mongo.Query)
	return ret0
}

// Select indicates an expected call of Select.
func (mr *MockQueryMockRecorder) Select(arg0 any) *MockQuerySelectCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Select", reflect.TypeOf((*MockQuery)(nil).Select), arg0)
	return &MockQuerySelectCall{Call: call}
}

// MockQuerySelectCall wrap *gomock.Call
type MockQuerySelectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQuerySelectCall) Return(arg0 mongo.Query) *MockQuerySelectCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQuerySelectCall) Do(f func(any) mongo.Query) *MockQuerySelectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQuerySelectCall) DoAndReturn(f func(any) mongo.Query) *MockQuerySelectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetMaxScan mocks base method.
func (m *MockQuery) SetMaxScan(arg0 int) mongo.Query {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetMaxScan", arg0)
	ret0, _ := ret[0].(mongo.Query)
	return ret0
}

// SetMaxScan indicates an expected call of SetMaxScan.
func (mr *MockQueryMockRecorder) SetMaxScan(arg0 any) *MockQuerySetMaxScanCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetMaxScan", reflect.TypeOf((*MockQuery)(nil).SetMaxScan), arg0)
	return &MockQuerySetMaxScanCall{Call: call}
}

// MockQuerySetMaxScanCall wrap *gomock.Call
type MockQuerySetMaxScanCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQuerySetMaxScanCall) Return(arg0 mongo.Query) *MockQuerySetMaxScanCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQuerySetMaxScanCall) Do(f func(int) mongo.Query) *MockQuerySetMaxScanCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQuerySetMaxScanCall) DoAndReturn(f func(int) mongo.Query) *MockQuerySetMaxScanCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetMaxTime mocks base method.
func (m *MockQuery) SetMaxTime(arg0 time.Duration) mongo.Query {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetMaxTime", arg0)
	ret0, _ := ret[0].(mongo.Query)
	return ret0
}

// SetMaxTime indicates an expected call of SetMaxTime.
func (mr *MockQueryMockRecorder) SetMaxTime(arg0 any) *MockQuerySetMaxTimeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetMaxTime", reflect.TypeOf((*MockQuery)(nil).SetMaxTime), arg0)
	return &MockQuerySetMaxTimeCall{Call: call}
}

// MockQuerySetMaxTimeCall wrap *gomock.Call
type MockQuerySetMaxTimeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQuerySetMaxTimeCall) Return(arg0 mongo.Query) *MockQuerySetMaxTimeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQuerySetMaxTimeCall) Do(f func(time.Duration) mongo.Query) *MockQuerySetMaxTimeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQuerySetMaxTimeCall) DoAndReturn(f func(time.Duration) mongo.Query) *MockQuerySetMaxTimeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Skip mocks base method.
func (m *MockQuery) Skip(arg0 int) mongo.Query {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Skip", arg0)
	ret0, _ := ret[0].(mongo.Query)
	return ret0
}

// Skip indicates an expected call of Skip.
func (mr *MockQueryMockRecorder) Skip(arg0 any) *MockQuerySkipCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Skip", reflect.TypeOf((*MockQuery)(nil).Skip), arg0)
	return &MockQuerySkipCall{Call: call}
}

// MockQuerySkipCall wrap *gomock.Call
type MockQuerySkipCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQuerySkipCall) Return(arg0 mongo.Query) *MockQuerySkipCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQuerySkipCall) Do(f func(int) mongo.Query) *MockQuerySkipCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQuerySkipCall) DoAndReturn(f func(int) mongo.Query) *MockQuerySkipCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Snapshot mocks base method.
func (m *MockQuery) Snapshot() mongo.Query {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Snapshot")
	ret0, _ := ret[0].(mongo.Query)
	return ret0
}

// Snapshot indicates an expected call of Snapshot.
func (mr *MockQueryMockRecorder) Snapshot() *MockQuerySnapshotCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Snapshot", reflect.TypeOf((*MockQuery)(nil).Snapshot))
	return &MockQuerySnapshotCall{Call: call}
}

// MockQuerySnapshotCall wrap *gomock.Call
type MockQuerySnapshotCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQuerySnapshotCall) Return(arg0 mongo.Query) *MockQuerySnapshotCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQuerySnapshotCall) Do(f func() mongo.Query) *MockQuerySnapshotCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQuerySnapshotCall) DoAndReturn(f func() mongo.Query) *MockQuerySnapshotCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Sort mocks base method.
func (m *MockQuery) Sort(arg0 ...string) mongo.Query {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Sort", varargs...)
	ret0, _ := ret[0].(mongo.Query)
	return ret0
}

// Sort indicates an expected call of Sort.
func (mr *MockQueryMockRecorder) Sort(arg0 ...any) *MockQuerySortCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sort", reflect.TypeOf((*MockQuery)(nil).Sort), arg0...)
	return &MockQuerySortCall{Call: call}
}

// MockQuerySortCall wrap *gomock.Call
type MockQuerySortCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQuerySortCall) Return(arg0 mongo.Query) *MockQuerySortCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQuerySortCall) Do(f func(...string) mongo.Query) *MockQuerySortCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQuerySortCall) DoAndReturn(f func(...string) mongo.Query) *MockQuerySortCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Tail mocks base method.
func (m *MockQuery) Tail(arg0 time.Duration) *mgo.Iter {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Tail", arg0)
	ret0, _ := ret[0].(*mgo.Iter)
	return ret0
}

// Tail indicates an expected call of Tail.
func (mr *MockQueryMockRecorder) Tail(arg0 any) *MockQueryTailCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Tail", reflect.TypeOf((*MockQuery)(nil).Tail), arg0)
	return &MockQueryTailCall{Call: call}
}

// MockQueryTailCall wrap *gomock.Call
type MockQueryTailCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQueryTailCall) Return(arg0 *mgo.Iter) *MockQueryTailCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQueryTailCall) Do(f func(time.Duration) *mgo.Iter) *MockQueryTailCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQueryTailCall) DoAndReturn(f func(time.Duration) *mgo.Iter) *MockQueryTailCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
