// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/juju/juju/apiserver/facades/client/application (interfaces: Bindings,DeployFromRepositoryState,DeployFromRepositoryValidator,Model,Machine)
//
// Generated by this command:
//
//	mockgen -typed -package application -destination deployrepository_mocks_test.go github.com/juju/juju/apiserver/facades/client/application Bindings,DeployFromRepositoryState,DeployFromRepositoryValidator,Model,Machine
//

// Package application is a generated GoMock package.
package application

import (
	context "context"
	reflect "reflect"

	resource "github.com/juju/charm/v13/resource"
	constraints "github.com/juju/juju/core/constraints"
	instance "github.com/juju/juju/core/instance"
	network "github.com/juju/juju/core/network"
	objectstore "github.com/juju/juju/core/objectstore"
	config "github.com/juju/juju/environs/config"
	services "github.com/juju/juju/internal/charm/services"
	params "github.com/juju/juju/rpc/params"
	state "github.com/juju/juju/state"
	names "github.com/juju/names/v5"
	version "github.com/juju/version/v2"
	gomock "go.uber.org/mock/gomock"
)

// MockBindings is a mock of Bindings interface.
type MockBindings struct {
	ctrl     *gomock.Controller
	recorder *MockBindingsMockRecorder
}

// MockBindingsMockRecorder is the mock recorder for MockBindings.
type MockBindingsMockRecorder struct {
	mock *MockBindings
}

// NewMockBindings creates a new mock instance.
func NewMockBindings(ctrl *gomock.Controller) *MockBindings {
	mock := &MockBindings{ctrl: ctrl}
	mock.recorder = &MockBindingsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBindings) EXPECT() *MockBindingsMockRecorder {
	return m.recorder
}

// Map mocks base method.
func (m *MockBindings) Map() map[string]string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Map")
	ret0, _ := ret[0].(map[string]string)
	return ret0
}

// Map indicates an expected call of Map.
func (mr *MockBindingsMockRecorder) Map() *MockBindingsMapCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Map", reflect.TypeOf((*MockBindings)(nil).Map))
	return &MockBindingsMapCall{Call: call}
}

// MockBindingsMapCall wrap *gomock.Call
type MockBindingsMapCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBindingsMapCall) Return(arg0 map[string]string) *MockBindingsMapCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBindingsMapCall) Do(f func() map[string]string) *MockBindingsMapCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBindingsMapCall) DoAndReturn(f func() map[string]string) *MockBindingsMapCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MapWithSpaceNames mocks base method.
func (m *MockBindings) MapWithSpaceNames(arg0 network.SpaceInfos) (map[string]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MapWithSpaceNames", arg0)
	ret0, _ := ret[0].(map[string]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MapWithSpaceNames indicates an expected call of MapWithSpaceNames.
func (mr *MockBindingsMockRecorder) MapWithSpaceNames(arg0 any) *MockBindingsMapWithSpaceNamesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MapWithSpaceNames", reflect.TypeOf((*MockBindings)(nil).MapWithSpaceNames), arg0)
	return &MockBindingsMapWithSpaceNamesCall{Call: call}
}

// MockBindingsMapWithSpaceNamesCall wrap *gomock.Call
type MockBindingsMapWithSpaceNamesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBindingsMapWithSpaceNamesCall) Return(arg0 map[string]string, arg1 error) *MockBindingsMapWithSpaceNamesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBindingsMapWithSpaceNamesCall) Do(f func(network.SpaceInfos) (map[string]string, error)) *MockBindingsMapWithSpaceNamesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBindingsMapWithSpaceNamesCall) DoAndReturn(f func(network.SpaceInfos) (map[string]string, error)) *MockBindingsMapWithSpaceNamesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockDeployFromRepositoryState is a mock of DeployFromRepositoryState interface.
type MockDeployFromRepositoryState struct {
	ctrl     *gomock.Controller
	recorder *MockDeployFromRepositoryStateMockRecorder
}

// MockDeployFromRepositoryStateMockRecorder is the mock recorder for MockDeployFromRepositoryState.
type MockDeployFromRepositoryStateMockRecorder struct {
	mock *MockDeployFromRepositoryState
}

// NewMockDeployFromRepositoryState creates a new mock instance.
func NewMockDeployFromRepositoryState(ctrl *gomock.Controller) *MockDeployFromRepositoryState {
	mock := &MockDeployFromRepositoryState{ctrl: ctrl}
	mock.recorder = &MockDeployFromRepositoryStateMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDeployFromRepositoryState) EXPECT() *MockDeployFromRepositoryStateMockRecorder {
	return m.recorder
}

// AddApplication mocks base method.
func (m *MockDeployFromRepositoryState) AddApplication(arg0 state.AddApplicationArgs, arg1 objectstore.ObjectStore) (Application, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddApplication", arg0, arg1)
	ret0, _ := ret[0].(Application)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddApplication indicates an expected call of AddApplication.
func (mr *MockDeployFromRepositoryStateMockRecorder) AddApplication(arg0, arg1 any) *MockDeployFromRepositoryStateAddApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddApplication", reflect.TypeOf((*MockDeployFromRepositoryState)(nil).AddApplication), arg0, arg1)
	return &MockDeployFromRepositoryStateAddApplicationCall{Call: call}
}

// MockDeployFromRepositoryStateAddApplicationCall wrap *gomock.Call
type MockDeployFromRepositoryStateAddApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryStateAddApplicationCall) Return(arg0 Application, arg1 error) *MockDeployFromRepositoryStateAddApplicationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryStateAddApplicationCall) Do(f func(state.AddApplicationArgs, objectstore.ObjectStore) (Application, error)) *MockDeployFromRepositoryStateAddApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryStateAddApplicationCall) DoAndReturn(f func(state.AddApplicationArgs, objectstore.ObjectStore) (Application, error)) *MockDeployFromRepositoryStateAddApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddCharmMetadata mocks base method.
func (m *MockDeployFromRepositoryState) AddCharmMetadata(arg0 state.CharmInfo) (Charm, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddCharmMetadata", arg0)
	ret0, _ := ret[0].(Charm)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddCharmMetadata indicates an expected call of AddCharmMetadata.
func (mr *MockDeployFromRepositoryStateMockRecorder) AddCharmMetadata(arg0 any) *MockDeployFromRepositoryStateAddCharmMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddCharmMetadata", reflect.TypeOf((*MockDeployFromRepositoryState)(nil).AddCharmMetadata), arg0)
	return &MockDeployFromRepositoryStateAddCharmMetadataCall{Call: call}
}

// MockDeployFromRepositoryStateAddCharmMetadataCall wrap *gomock.Call
type MockDeployFromRepositoryStateAddCharmMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryStateAddCharmMetadataCall) Return(arg0 Charm, arg1 error) *MockDeployFromRepositoryStateAddCharmMetadataCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryStateAddCharmMetadataCall) Do(f func(state.CharmInfo) (Charm, error)) *MockDeployFromRepositoryStateAddCharmMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryStateAddCharmMetadataCall) DoAndReturn(f func(state.CharmInfo) (Charm, error)) *MockDeployFromRepositoryStateAddCharmMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddPendingResource mocks base method.
func (m *MockDeployFromRepositoryState) AddPendingResource(arg0 string, arg1 resource.Resource, arg2 objectstore.ObjectStore) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddPendingResource", arg0, arg1, arg2)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddPendingResource indicates an expected call of AddPendingResource.
func (mr *MockDeployFromRepositoryStateMockRecorder) AddPendingResource(arg0, arg1, arg2 any) *MockDeployFromRepositoryStateAddPendingResourceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPendingResource", reflect.TypeOf((*MockDeployFromRepositoryState)(nil).AddPendingResource), arg0, arg1, arg2)
	return &MockDeployFromRepositoryStateAddPendingResourceCall{Call: call}
}

// MockDeployFromRepositoryStateAddPendingResourceCall wrap *gomock.Call
type MockDeployFromRepositoryStateAddPendingResourceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryStateAddPendingResourceCall) Return(arg0 string, arg1 error) *MockDeployFromRepositoryStateAddPendingResourceCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryStateAddPendingResourceCall) Do(f func(string, resource.Resource, objectstore.ObjectStore) (string, error)) *MockDeployFromRepositoryStateAddPendingResourceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryStateAddPendingResourceCall) DoAndReturn(f func(string, resource.Resource, objectstore.ObjectStore) (string, error)) *MockDeployFromRepositoryStateAddPendingResourceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Charm mocks base method.
func (m *MockDeployFromRepositoryState) Charm(arg0 string) (Charm, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Charm", arg0)
	ret0, _ := ret[0].(Charm)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Charm indicates an expected call of Charm.
func (mr *MockDeployFromRepositoryStateMockRecorder) Charm(arg0 any) *MockDeployFromRepositoryStateCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Charm", reflect.TypeOf((*MockDeployFromRepositoryState)(nil).Charm), arg0)
	return &MockDeployFromRepositoryStateCharmCall{Call: call}
}

// MockDeployFromRepositoryStateCharmCall wrap *gomock.Call
type MockDeployFromRepositoryStateCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryStateCharmCall) Return(arg0 Charm, arg1 error) *MockDeployFromRepositoryStateCharmCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryStateCharmCall) Do(f func(string) (Charm, error)) *MockDeployFromRepositoryStateCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryStateCharmCall) DoAndReturn(f func(string) (Charm, error)) *MockDeployFromRepositoryStateCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Machine mocks base method.
func (m *MockDeployFromRepositoryState) Machine(arg0 string) (Machine, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Machine", arg0)
	ret0, _ := ret[0].(Machine)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Machine indicates an expected call of Machine.
func (mr *MockDeployFromRepositoryStateMockRecorder) Machine(arg0 any) *MockDeployFromRepositoryStateMachineCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Machine", reflect.TypeOf((*MockDeployFromRepositoryState)(nil).Machine), arg0)
	return &MockDeployFromRepositoryStateMachineCall{Call: call}
}

// MockDeployFromRepositoryStateMachineCall wrap *gomock.Call
type MockDeployFromRepositoryStateMachineCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryStateMachineCall) Return(arg0 Machine, arg1 error) *MockDeployFromRepositoryStateMachineCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryStateMachineCall) Do(f func(string) (Machine, error)) *MockDeployFromRepositoryStateMachineCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryStateMachineCall) DoAndReturn(f func(string) (Machine, error)) *MockDeployFromRepositoryStateMachineCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ModelConstraints mocks base method.
func (m *MockDeployFromRepositoryState) ModelConstraints() (constraints.Value, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ModelConstraints")
	ret0, _ := ret[0].(constraints.Value)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ModelConstraints indicates an expected call of ModelConstraints.
func (mr *MockDeployFromRepositoryStateMockRecorder) ModelConstraints() *MockDeployFromRepositoryStateModelConstraintsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ModelConstraints", reflect.TypeOf((*MockDeployFromRepositoryState)(nil).ModelConstraints))
	return &MockDeployFromRepositoryStateModelConstraintsCall{Call: call}
}

// MockDeployFromRepositoryStateModelConstraintsCall wrap *gomock.Call
type MockDeployFromRepositoryStateModelConstraintsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryStateModelConstraintsCall) Return(arg0 constraints.Value, arg1 error) *MockDeployFromRepositoryStateModelConstraintsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryStateModelConstraintsCall) Do(f func() (constraints.Value, error)) *MockDeployFromRepositoryStateModelConstraintsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryStateModelConstraintsCall) DoAndReturn(f func() (constraints.Value, error)) *MockDeployFromRepositoryStateModelConstraintsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ModelUUID mocks base method.
func (m *MockDeployFromRepositoryState) ModelUUID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ModelUUID")
	ret0, _ := ret[0].(string)
	return ret0
}

// ModelUUID indicates an expected call of ModelUUID.
func (mr *MockDeployFromRepositoryStateMockRecorder) ModelUUID() *MockDeployFromRepositoryStateModelUUIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ModelUUID", reflect.TypeOf((*MockDeployFromRepositoryState)(nil).ModelUUID))
	return &MockDeployFromRepositoryStateModelUUIDCall{Call: call}
}

// MockDeployFromRepositoryStateModelUUIDCall wrap *gomock.Call
type MockDeployFromRepositoryStateModelUUIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryStateModelUUIDCall) Return(arg0 string) *MockDeployFromRepositoryStateModelUUIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryStateModelUUIDCall) Do(f func() string) *MockDeployFromRepositoryStateModelUUIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryStateModelUUIDCall) DoAndReturn(f func() string) *MockDeployFromRepositoryStateModelUUIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PrepareCharmUpload mocks base method.
func (m *MockDeployFromRepositoryState) PrepareCharmUpload(arg0 string) (services.UploadedCharm, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrepareCharmUpload", arg0)
	ret0, _ := ret[0].(services.UploadedCharm)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PrepareCharmUpload indicates an expected call of PrepareCharmUpload.
func (mr *MockDeployFromRepositoryStateMockRecorder) PrepareCharmUpload(arg0 any) *MockDeployFromRepositoryStatePrepareCharmUploadCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrepareCharmUpload", reflect.TypeOf((*MockDeployFromRepositoryState)(nil).PrepareCharmUpload), arg0)
	return &MockDeployFromRepositoryStatePrepareCharmUploadCall{Call: call}
}

// MockDeployFromRepositoryStatePrepareCharmUploadCall wrap *gomock.Call
type MockDeployFromRepositoryStatePrepareCharmUploadCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryStatePrepareCharmUploadCall) Return(arg0 services.UploadedCharm, arg1 error) *MockDeployFromRepositoryStatePrepareCharmUploadCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryStatePrepareCharmUploadCall) Do(f func(string) (services.UploadedCharm, error)) *MockDeployFromRepositoryStatePrepareCharmUploadCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryStatePrepareCharmUploadCall) DoAndReturn(f func(string) (services.UploadedCharm, error)) *MockDeployFromRepositoryStatePrepareCharmUploadCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadSequence mocks base method.
func (m *MockDeployFromRepositoryState) ReadSequence(arg0 string) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadSequence", arg0)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadSequence indicates an expected call of ReadSequence.
func (mr *MockDeployFromRepositoryStateMockRecorder) ReadSequence(arg0 any) *MockDeployFromRepositoryStateReadSequenceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadSequence", reflect.TypeOf((*MockDeployFromRepositoryState)(nil).ReadSequence), arg0)
	return &MockDeployFromRepositoryStateReadSequenceCall{Call: call}
}

// MockDeployFromRepositoryStateReadSequenceCall wrap *gomock.Call
type MockDeployFromRepositoryStateReadSequenceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryStateReadSequenceCall) Return(arg0 int, arg1 error) *MockDeployFromRepositoryStateReadSequenceCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryStateReadSequenceCall) Do(f func(string) (int, error)) *MockDeployFromRepositoryStateReadSequenceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryStateReadSequenceCall) DoAndReturn(f func(string) (int, error)) *MockDeployFromRepositoryStateReadSequenceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemovePendingResources mocks base method.
func (m *MockDeployFromRepositoryState) RemovePendingResources(arg0 string, arg1 map[string]string, arg2 objectstore.ObjectStore) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemovePendingResources", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemovePendingResources indicates an expected call of RemovePendingResources.
func (mr *MockDeployFromRepositoryStateMockRecorder) RemovePendingResources(arg0, arg1, arg2 any) *MockDeployFromRepositoryStateRemovePendingResourcesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemovePendingResources", reflect.TypeOf((*MockDeployFromRepositoryState)(nil).RemovePendingResources), arg0, arg1, arg2)
	return &MockDeployFromRepositoryStateRemovePendingResourcesCall{Call: call}
}

// MockDeployFromRepositoryStateRemovePendingResourcesCall wrap *gomock.Call
type MockDeployFromRepositoryStateRemovePendingResourcesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryStateRemovePendingResourcesCall) Return(arg0 error) *MockDeployFromRepositoryStateRemovePendingResourcesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryStateRemovePendingResourcesCall) Do(f func(string, map[string]string, objectstore.ObjectStore) error) *MockDeployFromRepositoryStateRemovePendingResourcesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryStateRemovePendingResourcesCall) DoAndReturn(f func(string, map[string]string, objectstore.ObjectStore) error) *MockDeployFromRepositoryStateRemovePendingResourcesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateUploadedCharm mocks base method.
func (m *MockDeployFromRepositoryState) UpdateUploadedCharm(arg0 state.CharmInfo) (services.UploadedCharm, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateUploadedCharm", arg0)
	ret0, _ := ret[0].(services.UploadedCharm)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateUploadedCharm indicates an expected call of UpdateUploadedCharm.
func (mr *MockDeployFromRepositoryStateMockRecorder) UpdateUploadedCharm(arg0 any) *MockDeployFromRepositoryStateUpdateUploadedCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUploadedCharm", reflect.TypeOf((*MockDeployFromRepositoryState)(nil).UpdateUploadedCharm), arg0)
	return &MockDeployFromRepositoryStateUpdateUploadedCharmCall{Call: call}
}

// MockDeployFromRepositoryStateUpdateUploadedCharmCall wrap *gomock.Call
type MockDeployFromRepositoryStateUpdateUploadedCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryStateUpdateUploadedCharmCall) Return(arg0 services.UploadedCharm, arg1 error) *MockDeployFromRepositoryStateUpdateUploadedCharmCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryStateUpdateUploadedCharmCall) Do(f func(state.CharmInfo) (services.UploadedCharm, error)) *MockDeployFromRepositoryStateUpdateUploadedCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryStateUpdateUploadedCharmCall) DoAndReturn(f func(state.CharmInfo) (services.UploadedCharm, error)) *MockDeployFromRepositoryStateUpdateUploadedCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockDeployFromRepositoryValidator is a mock of DeployFromRepositoryValidator interface.
type MockDeployFromRepositoryValidator struct {
	ctrl     *gomock.Controller
	recorder *MockDeployFromRepositoryValidatorMockRecorder
}

// MockDeployFromRepositoryValidatorMockRecorder is the mock recorder for MockDeployFromRepositoryValidator.
type MockDeployFromRepositoryValidatorMockRecorder struct {
	mock *MockDeployFromRepositoryValidator
}

// NewMockDeployFromRepositoryValidator creates a new mock instance.
func NewMockDeployFromRepositoryValidator(ctrl *gomock.Controller) *MockDeployFromRepositoryValidator {
	mock := &MockDeployFromRepositoryValidator{ctrl: ctrl}
	mock.recorder = &MockDeployFromRepositoryValidatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDeployFromRepositoryValidator) EXPECT() *MockDeployFromRepositoryValidatorMockRecorder {
	return m.recorder
}

// ValidateArg mocks base method.
func (m *MockDeployFromRepositoryValidator) ValidateArg(arg0 context.Context, arg1 params.DeployFromRepositoryArg) (deployTemplate, []error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateArg", arg0, arg1)
	ret0, _ := ret[0].(deployTemplate)
	ret1, _ := ret[1].([]error)
	return ret0, ret1
}

// ValidateArg indicates an expected call of ValidateArg.
func (mr *MockDeployFromRepositoryValidatorMockRecorder) ValidateArg(arg0, arg1 any) *MockDeployFromRepositoryValidatorValidateArgCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateArg", reflect.TypeOf((*MockDeployFromRepositoryValidator)(nil).ValidateArg), arg0, arg1)
	return &MockDeployFromRepositoryValidatorValidateArgCall{Call: call}
}

// MockDeployFromRepositoryValidatorValidateArgCall wrap *gomock.Call
type MockDeployFromRepositoryValidatorValidateArgCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryValidatorValidateArgCall) Return(arg0 deployTemplate, arg1 []error) *MockDeployFromRepositoryValidatorValidateArgCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryValidatorValidateArgCall) Do(f func(context.Context, params.DeployFromRepositoryArg) (deployTemplate, []error)) *MockDeployFromRepositoryValidatorValidateArgCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryValidatorValidateArgCall) DoAndReturn(f func(context.Context, params.DeployFromRepositoryArg) (deployTemplate, []error)) *MockDeployFromRepositoryValidatorValidateArgCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockModel is a mock of Model interface.
type MockModel struct {
	ctrl     *gomock.Controller
	recorder *MockModelMockRecorder
}

// MockModelMockRecorder is the mock recorder for MockModel.
type MockModelMockRecorder struct {
	mock *MockModel
}

// NewMockModel creates a new mock instance.
func NewMockModel(ctrl *gomock.Controller) *MockModel {
	mock := &MockModel{ctrl: ctrl}
	mock.recorder = &MockModelMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockModel) EXPECT() *MockModelMockRecorder {
	return m.recorder
}

// AgentVersion mocks base method.
func (m *MockModel) AgentVersion() (version.Number, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AgentVersion")
	ret0, _ := ret[0].(version.Number)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AgentVersion indicates an expected call of AgentVersion.
func (mr *MockModelMockRecorder) AgentVersion() *MockModelAgentVersionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AgentVersion", reflect.TypeOf((*MockModel)(nil).AgentVersion))
	return &MockModelAgentVersionCall{Call: call}
}

// MockModelAgentVersionCall wrap *gomock.Call
type MockModelAgentVersionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelAgentVersionCall) Return(arg0 version.Number, arg1 error) *MockModelAgentVersionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelAgentVersionCall) Do(f func() (version.Number, error)) *MockModelAgentVersionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelAgentVersionCall) DoAndReturn(f func() (version.Number, error)) *MockModelAgentVersionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CloudCredentialTag mocks base method.
func (m *MockModel) CloudCredentialTag() (names.CloudCredentialTag, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CloudCredentialTag")
	ret0, _ := ret[0].(names.CloudCredentialTag)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// CloudCredentialTag indicates an expected call of CloudCredentialTag.
func (mr *MockModelMockRecorder) CloudCredentialTag() *MockModelCloudCredentialTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloudCredentialTag", reflect.TypeOf((*MockModel)(nil).CloudCredentialTag))
	return &MockModelCloudCredentialTagCall{Call: call}
}

// MockModelCloudCredentialTagCall wrap *gomock.Call
type MockModelCloudCredentialTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelCloudCredentialTagCall) Return(arg0 names.CloudCredentialTag, arg1 bool) *MockModelCloudCredentialTagCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelCloudCredentialTagCall) Do(f func() (names.CloudCredentialTag, bool)) *MockModelCloudCredentialTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelCloudCredentialTagCall) DoAndReturn(f func() (names.CloudCredentialTag, bool)) *MockModelCloudCredentialTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CloudName mocks base method.
func (m *MockModel) CloudName() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CloudName")
	ret0, _ := ret[0].(string)
	return ret0
}

// CloudName indicates an expected call of CloudName.
func (mr *MockModelMockRecorder) CloudName() *MockModelCloudNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloudName", reflect.TypeOf((*MockModel)(nil).CloudName))
	return &MockModelCloudNameCall{Call: call}
}

// MockModelCloudNameCall wrap *gomock.Call
type MockModelCloudNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelCloudNameCall) Return(arg0 string) *MockModelCloudNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelCloudNameCall) Do(f func() string) *MockModelCloudNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelCloudNameCall) DoAndReturn(f func() string) *MockModelCloudNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CloudRegion mocks base method.
func (m *MockModel) CloudRegion() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CloudRegion")
	ret0, _ := ret[0].(string)
	return ret0
}

// CloudRegion indicates an expected call of CloudRegion.
func (mr *MockModelMockRecorder) CloudRegion() *MockModelCloudRegionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloudRegion", reflect.TypeOf((*MockModel)(nil).CloudRegion))
	return &MockModelCloudRegionCall{Call: call}
}

// MockModelCloudRegionCall wrap *gomock.Call
type MockModelCloudRegionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelCloudRegionCall) Return(arg0 string) *MockModelCloudRegionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelCloudRegionCall) Do(f func() string) *MockModelCloudRegionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelCloudRegionCall) DoAndReturn(f func() string) *MockModelCloudRegionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Config mocks base method.
func (m *MockModel) Config() (*config.Config, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Config")
	ret0, _ := ret[0].(*config.Config)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Config indicates an expected call of Config.
func (mr *MockModelMockRecorder) Config() *MockModelConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Config", reflect.TypeOf((*MockModel)(nil).Config))
	return &MockModelConfigCall{Call: call}
}

// MockModelConfigCall wrap *gomock.Call
type MockModelConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelConfigCall) Return(arg0 *config.Config, arg1 error) *MockModelConfigCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelConfigCall) Do(f func() (*config.Config, error)) *MockModelConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelConfigCall) DoAndReturn(f func() (*config.Config, error)) *MockModelConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ControllerUUID mocks base method.
func (m *MockModel) ControllerUUID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ControllerUUID")
	ret0, _ := ret[0].(string)
	return ret0
}

// ControllerUUID indicates an expected call of ControllerUUID.
func (mr *MockModelMockRecorder) ControllerUUID() *MockModelControllerUUIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ControllerUUID", reflect.TypeOf((*MockModel)(nil).ControllerUUID))
	return &MockModelControllerUUIDCall{Call: call}
}

// MockModelControllerUUIDCall wrap *gomock.Call
type MockModelControllerUUIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelControllerUUIDCall) Return(arg0 string) *MockModelControllerUUIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelControllerUUIDCall) Do(f func() string) *MockModelControllerUUIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelControllerUUIDCall) DoAndReturn(f func() string) *MockModelControllerUUIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ModelConfig mocks base method.
func (m *MockModel) ModelConfig(arg0 context.Context) (*config.Config, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ModelConfig", arg0)
	ret0, _ := ret[0].(*config.Config)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ModelConfig indicates an expected call of ModelConfig.
func (mr *MockModelMockRecorder) ModelConfig(arg0 any) *MockModelModelConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ModelConfig", reflect.TypeOf((*MockModel)(nil).ModelConfig), arg0)
	return &MockModelModelConfigCall{Call: call}
}

// MockModelModelConfigCall wrap *gomock.Call
type MockModelModelConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelModelConfigCall) Return(arg0 *config.Config, arg1 error) *MockModelModelConfigCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelModelConfigCall) Do(f func(context.Context) (*config.Config, error)) *MockModelModelConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelModelConfigCall) DoAndReturn(f func(context.Context) (*config.Config, error)) *MockModelModelConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ModelTag mocks base method.
func (m *MockModel) ModelTag() names.ModelTag {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ModelTag")
	ret0, _ := ret[0].(names.ModelTag)
	return ret0
}

// ModelTag indicates an expected call of ModelTag.
func (mr *MockModelMockRecorder) ModelTag() *MockModelModelTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ModelTag", reflect.TypeOf((*MockModel)(nil).ModelTag))
	return &MockModelModelTagCall{Call: call}
}

// MockModelModelTagCall wrap *gomock.Call
type MockModelModelTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelModelTagCall) Return(arg0 names.ModelTag) *MockModelModelTagCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelModelTagCall) Do(f func() names.ModelTag) *MockModelModelTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelModelTagCall) DoAndReturn(f func() names.ModelTag) *MockModelModelTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Name mocks base method.
func (m *MockModel) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockModelMockRecorder) Name() *MockModelNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockModel)(nil).Name))
	return &MockModelNameCall{Call: call}
}

// MockModelNameCall wrap *gomock.Call
type MockModelNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelNameCall) Return(arg0 string) *MockModelNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelNameCall) Do(f func() string) *MockModelNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelNameCall) DoAndReturn(f func() string) *MockModelNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// OpenedPortRangesForMachine mocks base method.
func (m *MockModel) OpenedPortRangesForMachine(arg0 string) (state.MachinePortRanges, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OpenedPortRangesForMachine", arg0)
	ret0, _ := ret[0].(state.MachinePortRanges)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OpenedPortRangesForMachine indicates an expected call of OpenedPortRangesForMachine.
func (mr *MockModelMockRecorder) OpenedPortRangesForMachine(arg0 any) *MockModelOpenedPortRangesForMachineCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OpenedPortRangesForMachine", reflect.TypeOf((*MockModel)(nil).OpenedPortRangesForMachine), arg0)
	return &MockModelOpenedPortRangesForMachineCall{Call: call}
}

// MockModelOpenedPortRangesForMachineCall wrap *gomock.Call
type MockModelOpenedPortRangesForMachineCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelOpenedPortRangesForMachineCall) Return(arg0 state.MachinePortRanges, arg1 error) *MockModelOpenedPortRangesForMachineCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelOpenedPortRangesForMachineCall) Do(f func(string) (state.MachinePortRanges, error)) *MockModelOpenedPortRangesForMachineCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelOpenedPortRangesForMachineCall) DoAndReturn(f func(string) (state.MachinePortRanges, error)) *MockModelOpenedPortRangesForMachineCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Owner mocks base method.
func (m *MockModel) Owner() names.UserTag {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Owner")
	ret0, _ := ret[0].(names.UserTag)
	return ret0
}

// Owner indicates an expected call of Owner.
func (mr *MockModelMockRecorder) Owner() *MockModelOwnerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Owner", reflect.TypeOf((*MockModel)(nil).Owner))
	return &MockModelOwnerCall{Call: call}
}

// MockModelOwnerCall wrap *gomock.Call
type MockModelOwnerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelOwnerCall) Return(arg0 names.UserTag) *MockModelOwnerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelOwnerCall) Do(f func() names.UserTag) *MockModelOwnerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelOwnerCall) DoAndReturn(f func() names.UserTag) *MockModelOwnerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Tag mocks base method.
func (m *MockModel) Tag() names.Tag {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Tag")
	ret0, _ := ret[0].(names.Tag)
	return ret0
}

// Tag indicates an expected call of Tag.
func (mr *MockModelMockRecorder) Tag() *MockModelTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Tag", reflect.TypeOf((*MockModel)(nil).Tag))
	return &MockModelTagCall{Call: call}
}

// MockModelTagCall wrap *gomock.Call
type MockModelTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelTagCall) Return(arg0 names.Tag) *MockModelTagCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelTagCall) Do(f func() names.Tag) *MockModelTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelTagCall) DoAndReturn(f func() names.Tag) *MockModelTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Type mocks base method.
func (m *MockModel) Type() state.ModelType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Type")
	ret0, _ := ret[0].(state.ModelType)
	return ret0
}

// Type indicates an expected call of Type.
func (mr *MockModelMockRecorder) Type() *MockModelTypeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Type", reflect.TypeOf((*MockModel)(nil).Type))
	return &MockModelTypeCall{Call: call}
}

// MockModelTypeCall wrap *gomock.Call
type MockModelTypeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelTypeCall) Return(arg0 state.ModelType) *MockModelTypeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelTypeCall) Do(f func() state.ModelType) *MockModelTypeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelTypeCall) DoAndReturn(f func() state.ModelType) *MockModelTypeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UUID mocks base method.
func (m *MockModel) UUID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UUID")
	ret0, _ := ret[0].(string)
	return ret0
}

// UUID indicates an expected call of UUID.
func (mr *MockModelMockRecorder) UUID() *MockModelUUIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UUID", reflect.TypeOf((*MockModel)(nil).UUID))
	return &MockModelUUIDCall{Call: call}
}

// MockModelUUIDCall wrap *gomock.Call
type MockModelUUIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelUUIDCall) Return(arg0 string) *MockModelUUIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelUUIDCall) Do(f func() string) *MockModelUUIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelUUIDCall) DoAndReturn(f func() string) *MockModelUUIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockMachine is a mock of Machine interface.
type MockMachine struct {
	ctrl     *gomock.Controller
	recorder *MockMachineMockRecorder
}

// MockMachineMockRecorder is the mock recorder for MockMachine.
type MockMachineMockRecorder struct {
	mock *MockMachine
}

// NewMockMachine creates a new mock instance.
func NewMockMachine(ctrl *gomock.Controller) *MockMachine {
	mock := &MockMachine{ctrl: ctrl}
	mock.recorder = &MockMachineMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMachine) EXPECT() *MockMachineMockRecorder {
	return m.recorder
}

// Base mocks base method.
func (m *MockMachine) Base() state.Base {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Base")
	ret0, _ := ret[0].(state.Base)
	return ret0
}

// Base indicates an expected call of Base.
func (mr *MockMachineMockRecorder) Base() *MockMachineBaseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Base", reflect.TypeOf((*MockMachine)(nil).Base))
	return &MockMachineBaseCall{Call: call}
}

// MockMachineBaseCall wrap *gomock.Call
type MockMachineBaseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineBaseCall) Return(arg0 state.Base) *MockMachineBaseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineBaseCall) Do(f func() state.Base) *MockMachineBaseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineBaseCall) DoAndReturn(f func() state.Base) *MockMachineBaseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HardwareCharacteristics mocks base method.
func (m *MockMachine) HardwareCharacteristics() (*instance.HardwareCharacteristics, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HardwareCharacteristics")
	ret0, _ := ret[0].(*instance.HardwareCharacteristics)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HardwareCharacteristics indicates an expected call of HardwareCharacteristics.
func (mr *MockMachineMockRecorder) HardwareCharacteristics() *MockMachineHardwareCharacteristicsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HardwareCharacteristics", reflect.TypeOf((*MockMachine)(nil).HardwareCharacteristics))
	return &MockMachineHardwareCharacteristicsCall{Call: call}
}

// MockMachineHardwareCharacteristicsCall wrap *gomock.Call
type MockMachineHardwareCharacteristicsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineHardwareCharacteristicsCall) Return(arg0 *instance.HardwareCharacteristics, arg1 error) *MockMachineHardwareCharacteristicsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineHardwareCharacteristicsCall) Do(f func() (*instance.HardwareCharacteristics, error)) *MockMachineHardwareCharacteristicsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineHardwareCharacteristicsCall) DoAndReturn(f func() (*instance.HardwareCharacteristics, error)) *MockMachineHardwareCharacteristicsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsLockedForSeriesUpgrade mocks base method.
func (m *MockMachine) IsLockedForSeriesUpgrade() (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsLockedForSeriesUpgrade")
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsLockedForSeriesUpgrade indicates an expected call of IsLockedForSeriesUpgrade.
func (mr *MockMachineMockRecorder) IsLockedForSeriesUpgrade() *MockMachineIsLockedForSeriesUpgradeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsLockedForSeriesUpgrade", reflect.TypeOf((*MockMachine)(nil).IsLockedForSeriesUpgrade))
	return &MockMachineIsLockedForSeriesUpgradeCall{Call: call}
}

// MockMachineIsLockedForSeriesUpgradeCall wrap *gomock.Call
type MockMachineIsLockedForSeriesUpgradeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineIsLockedForSeriesUpgradeCall) Return(arg0 bool, arg1 error) *MockMachineIsLockedForSeriesUpgradeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineIsLockedForSeriesUpgradeCall) Do(f func() (bool, error)) *MockMachineIsLockedForSeriesUpgradeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineIsLockedForSeriesUpgradeCall) DoAndReturn(f func() (bool, error)) *MockMachineIsLockedForSeriesUpgradeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsParentLockedForSeriesUpgrade mocks base method.
func (m *MockMachine) IsParentLockedForSeriesUpgrade() (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsParentLockedForSeriesUpgrade")
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsParentLockedForSeriesUpgrade indicates an expected call of IsParentLockedForSeriesUpgrade.
func (mr *MockMachineMockRecorder) IsParentLockedForSeriesUpgrade() *MockMachineIsParentLockedForSeriesUpgradeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsParentLockedForSeriesUpgrade", reflect.TypeOf((*MockMachine)(nil).IsParentLockedForSeriesUpgrade))
	return &MockMachineIsParentLockedForSeriesUpgradeCall{Call: call}
}

// MockMachineIsParentLockedForSeriesUpgradeCall wrap *gomock.Call
type MockMachineIsParentLockedForSeriesUpgradeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineIsParentLockedForSeriesUpgradeCall) Return(arg0 bool, arg1 error) *MockMachineIsParentLockedForSeriesUpgradeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineIsParentLockedForSeriesUpgradeCall) Do(f func() (bool, error)) *MockMachineIsParentLockedForSeriesUpgradeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineIsParentLockedForSeriesUpgradeCall) DoAndReturn(f func() (bool, error)) *MockMachineIsParentLockedForSeriesUpgradeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PublicAddress mocks base method.
func (m *MockMachine) PublicAddress() (network.SpaceAddress, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PublicAddress")
	ret0, _ := ret[0].(network.SpaceAddress)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PublicAddress indicates an expected call of PublicAddress.
func (mr *MockMachineMockRecorder) PublicAddress() *MockMachinePublicAddressCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublicAddress", reflect.TypeOf((*MockMachine)(nil).PublicAddress))
	return &MockMachinePublicAddressCall{Call: call}
}

// MockMachinePublicAddressCall wrap *gomock.Call
type MockMachinePublicAddressCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachinePublicAddressCall) Return(arg0 network.SpaceAddress, arg1 error) *MockMachinePublicAddressCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachinePublicAddressCall) Do(f func() (network.SpaceAddress, error)) *MockMachinePublicAddressCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachinePublicAddressCall) DoAndReturn(f func() (network.SpaceAddress, error)) *MockMachinePublicAddressCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
